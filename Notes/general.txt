nodeJs est fait pour pouvoir executer du JavaScript dans les machines (traduire javascript en code machine ) 



pour l'exportation des methode on peut utiliser export dans la declaration de la methode "export.name"
pour l'importation on peut importer juste qlq fonction que d'importer tout le fichier et cela en utilisant un objet 
qui contient juste les methode qu'on veut imoprter const {func1,func2...}  = require {'./file_name'};
il existe des module qui sont integrer dans  nodejs et on peut les importer sans specifier le path 

on peut utiliser "express" c un module qu'on import et on utiliser ses fonction, parmis ses fonction ya la fonction " get " ou ca nous fait un request a partir d'un url 
et on lui donne une response mais a travers une callback function et pour savoir la response on doit specifie une porte ( en donnant son numero ) aprs on doit acceder 
a cette porte en ecrivant "localhost:Num_Porte"

on peut importer le module "fs" file systeme qui contient bkp de fonction qu'on peut travailler avec 
fs.writeFileSync('File_Name','texte');	 
ya aussi le fs.writeFile() qui peut prendre 3 arguments le nom , contenue et une callback qui s'execute une fois on a terminer l'ecriture du fichier 

node js is a asynchrounous programming : si ya plsr taches a faire on ouvre plsr thread  donc si on a une commande qui dure long temps on va pas executer chaque instruction 
a son tours une instruction peut s'xecuter avant une instruction qui est avant 
pour les request on utilis http.createserver(); qui prend une fonction comme paramettre et l'execute kan ya un request et pour cela on peut definir une fonction ou utiliser les arrow functions 


event loop c comme un process qui s'execute en boucle ce dernier est la fonction qu'on passe au server 

pour envoyer des response  on utilise "res.write()" et on precise le file kan veut envoyer a la fin  on fait un "res.end()" pour dir la fin du response 

pour gerer un response il faut tjr verifier le nom de la methode si c un POST ou un GET

req.on() c une fonction qui nous permet de gerer les event elle prend un argument pour specifie le type de l'event et 
le callback function qui sera executer kan y'aura l'event 

on va utiliser des chunks(des parties) pour les requests on va les stocker dans un tab puis on va les concatener dans une 
buffer 

pour l'exportation on peut exporter une focntion directement ou exporter un objet qui a plsr proprieté comme on peut faire ceci "module.export.method_name" 
et ya aussi un shortcut "exports.method_name"


si on aura un commande qu'on utilise plsr fois on peut la modifier dans npm init en ajoutant un script qui l'execute 
pour le script "start" on utilise "npm start" mais pour les autres on utilise "npm run script_name"
the "third party modules" c les packages qui sont installer depuis npm   


pour simplifier les chose on va utiliser expressJS et cela nous donne la main a plsr fonction predefinie et nous 
aide a fonder notre app 
parmis ces function on a "use()" on lui donne une fonction et cette derniere sera executer kan ya un request , la fonction 
prend 3 argument (res,req, next) next c une autre fonction qui permet au request de passer au middelware prochain on peut ajouter 
un argument au "use()" qui est le path (kima kouna ndirou fel bedya te3 "/" et "/users")  et ca veut dir que le path apres 
le domain doit commencer par "/" ... ( ki ndirou "/" donc ge3 les autres path ghadi ydirou le mm response que "/" ) si il ya un middelware qui traite tout les request alors il faut le faire en premier 
si on inverse entre les middelware et on met le "/" dans le debut alors tout les request qui vont venir vont  etre traiter par le "/" middelware car tout les path comment par "/" donc il faut placer le "/" en dernier pour que les autres path soient traiter 
on peut utiliser "app.get()" qui traite juste les 'get requests ' la mm chose pour "app.POST()"
pour etre traiter 
pour gerer les response on peut utiliser la fonction "res.send()" en lui danant en paramettre le response 
si les methode son diff(get/post) donc on peut utiliser le mm "url" 
pour servir un fichier html au client il faut le donner a la fontion sendFile et pour cela il faut specifie un path pour le fichier et pour cela il faut utiliser le module path avec la fontion join(__dirname)  qui nous donne automatiquement le path a notre fichier 
ma fontion join build a path suivant l'OP qu'on utilise windows ou linux 
app.set(name,value) ca nous permet d'ajouter une var global (ca nous aide dans la configuration )  on peut modifier plsr var global parmis ces derniers on a "view engine " qui designe le modéle du template qu'o veut utiliser 
et "views" c ou on peut trouver ces templates ( par default est le dossier "views" mais si on veut le changer on a qu'a ajouter un path pour le dossier )
pour servir des page html dynamique on utilise "templating engine" et pour faire cela on va utiliser la methode res.render('file_name') sans specifier l'extension car on la deja specifie dans la declaration du "views engines" 
pour passer des donnée dynamique a html il faut ajouter un paramettre au "render function " qui est un object qui contient les donnée dynamique  (dans cet objet il faut donner une key pour chaque proprieté pour la referer dans les templates)  
dans les pug si on specifie pas c quoi alors c une Div et pour faire une boucle on utilise "each" 
pour les line de code qui se repete tout le temps on peut ajouter des layout qui sont des "pug files "  et koul maykoun kaien swaleh yetbedlou men page l page ndirou 3andha "block Name"
on peut utiliser les "if-statement" dans la pug et cela en utilisant la steucture suivante : boolean ? code_when_boolean_is_true : code_when_boolean_is_false  dans les attribues 


pour utiliser les handelbars c pas comme les pug donc il faut importer "express-handelbars" apres apeller la fonction app.engine apres il faut designer l'extension des fichier handelbars qui utilisent html   
les handelbars ne support pas des conditions dans les if il suportent que des boolean c pour cela il faut donner la condition a uen var (cad si on a une logic il faut l'implementer en nodeJs et n'ont pas en template car si on aura un blem on va consulter que le node et non pas le node et les templates) 
si on veut que notre template n'utilise pas le layout par default alorsd on ajout une key dans fichier kan envoie (fichier d'objets) qui est layout : false 
et pour les layout il faut ajouter l'extention "hbs" dans app.js

pour rendre les page html dynamique on peut utiliser les fichier ejs qui sont un melange entre html et javascript et ans les ejs ya pas la notion de layouts donc on va créer plsr files qui contienent le code commun entres tout les page 
dans les ejs si on fait ca : <%= VAR %> il va traiter le contenue du VAR comme texte mais si on faut cela <%- VAR %> il va traiter VAR comme un code html




pour le login on va utiliser the sessions mais o va stocker l'id de chaque session dans une cookie mais pas juste comme ca mais a traver 
un algo qui va cripter l'id de de chaque session pour eviter les attaque 

NB: les sessions sont stocker dans  LE SERVER SIDE mais les cookies sans stocker dans LE CLIENT SIDE c pour cela il faut pas 
utiliser les cookies pour les données sensibles   

pour utiliser les session on va utiliser 'express-session' ce packege ne permet de manipuler les session 
pour l'initialisation d'un session il faut definir un middelware (on donne a ce dernier session(... avec un object de config dedans))
NB: on peut configurer la cookie dans la session 
on peut stocke dans les sessions tout data qui concerne chaque user et qu'on veut pas les perdre une fois on fait un response 

donc pour simuler le logout il faut supprimer la session et pour faire cela : req.session.destroy(//... la fonction a executer apres la supprression )


NB: pour donner qlq data pour les views on va utiliser des var locals et pour cela on ajoute on middelware dans app.js pour les ajouter dans les views

kan on stocke l'object 'user' dans les session il a un blem qui est que lors de l'utilisation de ce dernier dans les controllers 
on va avoir juste les donnée de l'object pas un object completement de sequelize avec tout ses methods et pour cela on va faire la solution suivante : 
        on va restocker l'object dans le request mais dans la recherche on va pas donner le id manuelement mais suivant le user qui est dans la session "req.session.user.id"

DANS LES ROUTES ON PEUT AJOUTER PLSR MIDDELWARE ET VONT ETRE TRAITER DE GAUCHE A DEROITE
        donc on peut ajouter un middelware pour proteger les routes des CSRF Attacks et cela en ajouter un middelware a tout les moddilware of the routes

pour se proteger des attacks CSRF on va utiliser les csrf token qui sont des hashedData on l'utiliser a chaque fois on peut generer une view cette ces valeur seront generer une fois 
on a un request qui est envoyer au serveur(les csrf use the sessions)
        


si on ne travaille pas avec sequelize mais avec sql ou mongo il faut proteger les routes pour que chaque utilisateur vois juste les produit qui veut les voir 
et cela en protegant les postRequests il faut verifier que ce produit appartient au mm user (avec sequelize on peut la verifier automatiquement)


pour la validation express-validator va passer les erreurs dans le req 
dans les validators on peut travailler avec les promises et pour cela on va introduire un promise dans le custom validator 
        pour express validator il va attendre la valeur de retour du promis si c fulfield alors c true si c rejected alors c error et cela s'appel "async validation" 



pour traiter les erreurs (pour le code synchronne) on peut travailler avec "try catch" l'avantage c que une fois on aura une erreur on va la traiter puis continuer notre code mais 
sans tray catch l'execution va s'arreter 
on peut donner a "next()" an error et pour cela pour lui dir que ya une erreur alors express va stopper tout les middelware et executer le errorMidelware 
        the errorMidelware a 4 argument error ,req,res,next
        pn peut avoir plusieur errorMidelware alors l'execution doit etre du haut au bas 
dans le code asynchrone on utilise tjr le next(err) et n'ont pas throw new Error() car cela ne va pas etre traiter par 
le errorMiddelware




DANS LE PROJET IL FAUT TRAITER CHAQUE ERREUR DANS UNE PAGE SPECIFIE AVEC UN MESSAGE SPECEFIE

pour la lecture des petit fichier on est bien de lire le fichier avec fs.readFile() et le server mais pour les grand fichier 
il faut utiliser d'autre methodes comme le streaming 
on peut utiliser des request behind the scene donc faire un travaille mais en gardant la mm page pour e client sans renvoyer des response 


si on a une application web qui est liée a une app mobile on utilise RESET API 
